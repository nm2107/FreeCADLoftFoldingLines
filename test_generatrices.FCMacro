# -*- coding: utf-8 -*-

import FreeCAD
from math import ceil
from DraftGeomUtils import findIntersection

def serializeVector(v: FreeCAD.Vector) -> str:
    return "%f;%f;%f" % (v.x, v.y, v.z)


def getTotalLengthOfNonLinearEdges(edges: [Part.Edge]) -> float:
    totalLength = 0.0

    for edge in edges:
        if isinstance(edge.Curve, Part.Line):
            continue

        totalLength += edge.Length

    return totalLength


class FoldingLine():
    """A folding line on the 3D shape."""
    def __init__(self, pointFaceA: FreeCAD.Vector, pointFaceB: FreeCAD.Vector):
        self.pointFaceA = pointFaceA
        self.pointFaceB = pointFaceB

    def getPointFaceA(self) -> FreeCAD.Vector:
        return self.pointFaceA

    def getPointFaceB(self) -> FreeCAD.Vector:
        return self.pointFaceB


class FlatFoldingLine(FoldingLine):
    """A flatten representation of a FoldingLine"""
    pass


class FoldingPoint():
    """A point used at one extremity of a FoldingLine"""
    def __init__(self, point: FreeCAD.Vector, tangent: FreeCAD.Vector):
        self.point = point
        self.tangent = tangent

    def getPoint(self) -> FreeCAD.Vector:
        return self.point

    def getTangent(self) -> FreeCAD.Vector:
        """Returns the tangent to the point on the edge on which the point was picked"""
        return self.tangent


def getFoldingPointsOnStraightEdge(edge: Part.Edge) -> [FoldingPoint]:
    firstPoint = edge.valueAt(edge.FirstParameter)
    lastPoint = edge.valueAt(edge.LastParameter)

    firstTangent = edge.tangentAt(edge.FirstParameter)
    lastTangent = edge.tangentAt(edge.LastParameter)

    return [
        FoldingPoint(firstPoint, firstTangent),
        FoldingPoint(lastPoint, lastTangent)
    ]


def buildFoldingPointsOnWire(wire: Part.Wire, maxPointsCount: int) -> [FoldingPoint]:
    # order the edges in a geometrical way (the end of one edge matches the start of the next one)
    edges = Part.__sortEdges__(wire.Edges)
    foldingPoints = dict()
    totalLengthOfNonLinearEdges = getTotalLengthOfNonLinearEdges(edges)

    chunksOffset = 0
    if len(edges) == 1:
        chunksOffset = 1

    for edge in edges:
        if isinstance(edge.Curve, Part.Line):
            # pick the start and end points of a straight line
            for foldingPoint in getFoldingPointsOnStraightEdge(edge):
                foldingPoints[serializeVector(foldingPoint.getPoint())] = foldingPoint

            continue

        # compare the length of this non linear edge to the total length of
        # non linear edges to know how many folding points we should place on it
        pointsToPlaceCount = round((edge.Length * maxPointsCount) / totalLengthOfNonLinearEdges)
        stepSize = 1 / pointsToPlaceCount

        # pick the evenly spaced points on edge
        for i in range(pointsToPlaceCount + chunksOffset):
            at = edge.FirstParameter + (stepSize * i) * (edge.LastParameter - edge.FirstParameter)
            foldingPoint = FoldingPoint(edge.valueAt(at), edge.tangentAt(at))
            serialized = serializeVector(foldingPoint.getPoint())

            if not serialized in foldingPoints:
                foldingPoints[serialized] = foldingPoint

    return list(foldingPoints.values())


# @see https://www.researchgate.net/publication/269052821_Convolutas_-_Piece-wise_Developable_Surfaces_using_two_Curved_Guidelines
# @see https://arxiv.org/pdf/2212.06589.pdf
def buildFoldingLines(pointsWireA: [FoldingPoint], pointsWireB: [FoldingPoint], tolerance: float) -> [FoldingLine]:
    foldingLines: [FoldingLine] = []

    for pointWireA in pointsWireA:
        for pointWireB in pointsWireB:
            # @see https://en.wikipedia.org/wiki/Coplanarity
            # @see https://en.wikipedia.org/wiki/Triple_product#Scalar_triple_product
            # @see https://github.com/Rentlau/WorkFeature/blob/eccc84fb1024a7394c158ba801772f858f1a4bc7/WorkFeature/WF.py#L11960
            va = pointWireA.getPoint().sub(pointWireB.getPoint())
            vb = pointWireA.getPoint().sub(pointWireA.getTangent())
            vc = pointWireB.getPoint().sub(pointWireB.getTangent())

            va.normalize()
            vb.normalize()
            vc.normalize()

            res = abs(va.dot(vb.cross(vc)))

            if (res < tolerance):
                foldingLines.append(FoldingLine(pointWireA.getPoint(), pointWireB.getPoint()))

    return foldingLines


def showFoldingLinesOn3DShape(foldingLines: [FoldingLine]) -> None:
    """Draw the folding lines on the 3D shape.
    """
    lines = []

    for foldingLine in foldingLines:
        lines.append(Part.makeLine(foldingLine.getPointFaceA(), foldingLine.getPointFaceB()))

    Part.show(Part.makeCompound(lines))


def flattenFoldingLine(foldingLines: [FoldingLine], previousFlatFoldingLine: FlatFoldingLine, i: int) -> FlatFoldingLine:
    """Computes the flatten representation of a folding line."""
    if (i < 1):
        return

    pointA = foldingLines[i].getPointFaceA()
    pointB = foldingLines[i].getPointFaceB()
    previousPointA = foldingLines[i - 1].getPointFaceA()
    previousPointB = foldingLines[i - 1].getPointFaceB()
    previousAFlat = previousFlatFoldingLine.getPointFaceA()
    previousBFlat = previousFlatFoldingLine.getPointFaceB()

    aStepLength = previousPointA.distanceToPoint(pointA)
    bStepLength = previousPointB.distanceToPoint(pointB)
    distAB = pointA.distanceToPoint(pointB)
    diagLength = previousPointA.distanceToPoint(pointB)

    if (0.0 == bStepLength):
        bFlat = previousBFlat
    else:
        # use circles to find the position of the bFlat point
        circleBStep = Part.makeCircle(bStepLength, previousBFlat)
        circleDiag = Part.makeCircle(diagLength, previousAFlat)
        bFlat = findIntersection(circleBStep, circleDiag)[0]

    if (0.0 == aStepLength):
        aFlat = previousAFlat
    else:
        # use circles to find the position of the aFlat point
        circleAStep = Part.makeCircle(aStepLength, previousAFlat)
        circleAFlatBFlat = Part.makeCircle(distAB, bFlat)
        aFlat = findIntersection(circleAStep, circleAFlatBFlat)[-1]

    return FlatFoldingLine(aFlat, bFlat)


def flattenFoldingLines(foldingLines: [FoldingLine]) -> [FlatFoldingLine]:
    """Computes the points of the flatten folding lines"""
    flatFoldingLines = []
    i = 0

    distAB = foldingLines[i].getPointFaceA().distanceToPoint(foldingLines[i].getPointFaceB())
    flatFoldingLine = FlatFoldingLine(FreeCAD.Vector(0.0, 0.0, 0.0), FreeCAD.Vector(distAB, 0.0, 0.0))

    previousFlatFoldingLine = flatFoldingLine
    flatFoldingLines.append(previousFlatFoldingLine)
    i += 1

    while (i < len(foldingLines)):
        previousFlatFoldingLine = flattenFoldingLine(foldingLines, previousFlatFoldingLine, i)
        flatFoldingLines.append(previousFlatFoldingLine)
        i += 1

    return flatFoldingLines


def buildFlatEdges(points: [FreeCAD.Vector], edges = []) -> None:
    """Link the given points by making edges, and add the created edges to the
    given edges array parameter.
    """
    i = 1

    while (i < len(points)):
        previousPoint = points[i - 1]
        currentPoint = points[i]
        i += 1

        if (previousPoint.distanceToPoint(currentPoint) < 1e-10):
            # Consider points as identical, so can't make a line.
            # If we try to make a line in this case, it would result into a
            # `BRepAdaptor_Curve::No geometry` error.
            continue

        edges.append(Part.makeLine(previousPoint, currentPoint))


def drawFlattenRepresentation(flatFoldingLines: [FlatFoldingLine]) -> None:
    """Draw the flatten representation of the shape and its folding lines.
    """
    edges = []
    foldingLinesCount = len(flatFoldingLines)

    flattenPointsA = []
    flattenPointsB = []

    for i in range(foldingLinesCount):
        flattenPointsA.append(flatFoldingLines[i].getPointFaceA())
        flattenPointsB.append(flatFoldingLines[i].getPointFaceB())

    # the flat edges of A & B wires
    buildFlatEdges(flattenPointsA, edges)
    buildFlatEdges(flattenPointsB, edges)

    i = 0
    while (i < foldingLinesCount):
        # the folding lines
        edges.append(Part.makeLine(flatFoldingLines[i].getPointFaceA(), flatFoldingLines[i].getPointFaceB()))
        i += 1

    Part.show(Part.makeCompound(edges))


def getWiresFromGuiSelection() -> (Part.Wire, Part.Wire):
    sel = Gui.Selection.getSelection()

    if 2 != len(sel):
        raise ValueError("Please select two sketches.")

    for s in sel:
        if "Sketcher::SketchObject" != s.TypeId:
            raise ValueError("Wrong selection, only sketches are allowed.")

    skA = sel[0]
    skB = sel[1]

    return (skA.Shape, skB.Shape)


def main():
    # @TODO : GUI to set angle, show folding lines on 3D shape opt, tolerance
    angle = 10.0
    maxPointsCount = ceil(360 / angle)
    tolerance = 1e-10

    wireFaceA, wireFaceB = getWiresFromGuiSelection()

    pointsWireA = buildFoldingPointsOnWire(wireFaceA, maxPointsCount)
    pointsWireB = buildFoldingPointsOnWire(wireFaceB, maxPointsCount)

    foldingLines = buildFoldingLines(pointsWireA, pointsWireB, tolerance)

    showFoldingLinesOn3DShape(foldingLines)

    flatFoldingLines = flattenFoldingLines(foldingLines)
    drawFlattenRepresentation(flatFoldingLines)


main()
